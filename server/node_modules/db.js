var fs = require('fs')
var mysql = require('mysql')
var connectionPoolFactory = require('connection-pool-factory')
var camelize = require('camelize')
var wrapPromise = require('wrap-promise')
var denodeify = require('then-denodeify')

var pool = connectionPoolFactory({
	host: '127.0.0.1',
	user: 'root',
	password: '',
	database: 'pos'
})

const getConnectionPromise = denodeify(cb => getWrappedConnectionFromPool(pool, cb))


module.exports.pool = pool
module.exports.promise = {
	singleConnection: promiseSingleConnection,
	getTransaction: () => promiseSingleConnection().then(connection => connection.transaction.start().then(() => connection))
}
module.exports.singleConnection = singleConnection

const modulesWithNames = fs.readdirSync('server/db')
	.filter(file => /^.+-db\.js$/.test(file))
	.map(filename => {
		const name = camelize(filename.substring(0, filename.length - '-db.js'.length))
		const dbModule = require('../db/' + filename)
		return {
			name,
			dbModule
		}
	})

modulesWithNames.forEach(({ dbModule, name }) => {
	const functions = createDbModuleObject(dbModule, pool)

	module.exports[name] = functions.callback
	module.exports.promise[name] = functions.promise
})


// need a version that returns a promise for the single-connection modules,
// and those should all be the promisified version

// regular version should return the regular db function object
function singleConnection() {
	return function(cb) {
		getWrappedConnectionFromPool(pool, (err, connection) => {
			if (err) return cb(err)

			cb(null, singleConnectionObject(connection))
		})
	}
}

function getWrappedConnectionFromPool(pool, cb) {
	pool.getConnection((err, connection) => {
		if (err) return cb(err)

		const wrappedConnection = Object.create(connection)

		wrappedConnection.query = function wrappedQuery(...args) {
			const originalCallback = args.pop()
			if (typeof originalCallback === 'function') {
				function wrappedCallback(err, results) {
					if (err) {
						console.error('QUERY ERROR DETECTED!')
						if (Array.isArray(args[1])) {
							console.error('in query', mysql.format.call(mysql, args[0], args[1]))
						} else {
							console.error('in query', args[0])
						}

						err.message = 'Query: ' + args[0] + '\n' + err.message
						originalCallback(err)
					} else {
						originalCallback(err, results)
					}
				}
				args.push(wrappedCallback)
			} else {
				args.push(originalCallback)
			}

			return connection.query.apply(connection, args)
		}

		cb(null, wrappedConnection)
	})
}

function promiseSingleConnection() {
	return getConnectionPromise().then(connection => {
		return singleConnectionObject(connection).promise
	})
}

function singleConnectionObject(connection) {
	const db = {
		promise: {}
	}

	modulesWithNames.forEach(({ dbModule, name }) => {
		const functions = createDbModuleObject(dbModule, connection)

		db[name] = functions.callback
		db.promise[name] = functions.promise
	})

	return db
}

function createDbModuleObject(dbModule, connection) {
	const dbFunctions = dbModule(connection)

	const promiseFunctions = Object.keys(dbFunctions).reduce((o, key) => {
		const fn = dbFunctions[key]
		o[key] = denodeify(fn, wrapPromise)
		return o
	}, {})

	return {
		callback: dbFunctions,
		promise: promiseFunctions
	}
}
